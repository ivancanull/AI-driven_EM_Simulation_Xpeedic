from math import remainder
from utils import *
from .input_features import *
from openpyxl import load_workbook

import numpy as np
import pandas as pd
import os

def generate_parameters_combinations(
    input_features: InputFeatures,
    configs: Config,
    samples: np.ndarray, 
    samelines: bool = True
):
    """
    Generate parameters for the scripts

    Args:
        input_features: InputFeatures
        configs: Config
        samples: the variable samples generated by the previous methods
        samelines: bool, whether different lines have different W and S

    Returns
        parameters_df: an pandas dataframe of shape (sampling_num, column_num), the sampled experimental settings for scripts

    """
    columns = read_input_feature_xlsx(configs.template_file.workbook_name, configs.template_file.dir)
    column_num = len(columns)
    sampling_num = samples.shape[0]
    parameters_df = pd.DataFrame(np.zeros((sampling_num, column_num)), columns=columns)
    for i in range(column_num):
        key = columns[i]
        
        # if the key is dir file name
        if key == 'save dir file name':
            # create the file names
            name_list = []
            for j in range(sampling_num):
                name_list.append("Stripline%d" % (j+1))
            parameters_df[key] = name_list
        
        # check if the column is a variable
        elif key in input_features.sampled_variables:
            sampled_idx = input_features.sampled_variables.index(key)
            parameters_df[key] = samples[:,sampled_idx]
        
        # check if the value is independent
        elif input_features.parameter_dict[key].has_standard:
            standard = input_features.parameter_dict[key].get_standard()
            # check if the standad value is a variable
            if standard in input_features.sampled_variables:
                sampled_idx = input_features.sampled_variables.index(standard)
                parameters_df[key] = samples[:,sampled_idx]
            else:
                # the standard value is not a variable
                parameters_df[key] = input_features.parameter_dict[standard].nominal
        # the value is not a variable
        else:  
            parameters_df[key] = input_features.parameter_dict[key].nominal

    # special treatment for W ans S
    n_line = input_features.parameter_dict['N-Line'].nominal

    if samelines:
        # expand W values
        original_W = parameters_df['W'].astype('str')
        for i in range(n_line-1):
            parameters_df['W'] = parameters_df['W'].astype('str') + ',' + original_W

        # expand S values
        original_S = parameters_df['S'].astype('str')
        for i in range(n_line-2):
            parameters_df['S'] = parameters_df['S'].astype('str') + ',' + original_S
    else:
        if not isinstance(input_features, MultiLineInputFeatures):
            raise TypeError('Input features must be multi-lines.')
        
        parameters_df['W'] = ''
        parameters_df['S'] = ''
        for idx, key in enumerate(input_features.sampled_variables):
            if 'W' in key:
                parameters_df['W'] = parameters_df['W'] + samples[:, idx].astype('str') + ','
            elif 'S' in key:
                parameters_df['S'] = parameters_df['S'] + samples[:, idx].astype('str') + ','
        
        parameters_df['W'] = parameters_df['W'].apply(lambda x: x.rstrip(','))
        parameters_df['S'] = parameters_df['S'].apply(lambda x: x.rstrip(','))
    return parameters_df

def write_script(
    parameters_df: pd.DataFrame,
    input_features: InputFeatures,
    configs: Config,
    saved_name: str,
    stackup_df: pd.DataFrame = None,
):
    """
    Write dataframes to scripts.

    Args:
        parameters_df: pd.DataFrame of input parameters
        input_features: InputFeatures
        configs: Config
        

    Returns:
        None, but write template xlsx into dataset generation directory
    """

    if "Mixed_N_Line_Stripline_Calcate" in configs.template_file.dir:
        workbook = load_workbook(filename=configs.template_file.dir)
        columns = read_input_feature_xlsx(configs.template_file.workbook_name, configs.template_file.dir)
        sheet_name = configs.template_file.workbook_name
        sheet = workbook[sheet_name]
        batch_num = configs.dataset_generation.batch_num
        column_num = len(columns)
        sampling_num = parameters_df.shape[0]
        idx = 0
        col = 2
        for i in range(sampling_num):
            
            if sheet_name == 'Mixed_N_Line_Stripline':
                for j in range(column_num):        
                    sheet.cell(row=25+j, column=col, value=parameters_df.iloc[i, j])
                col += 1
            else:
                raise NotImplementedError

            # Save the batch script
            if (col == batch_num+2) or (i == sampling_num-1):
                
                # Write frequency
                if sheet_name == 'Mixed_N_Line_Stripline':
                    for k in range(6):
                        sheet.cell(row=21, column=k+2, value=input_features.frequency[k])
                else:
                    raise NotImplementedError
                
                # Define the output dir
                out_dir = os.path.abspath(os.path.join(os.getcwd(), configs.dataset_generation.dir, saved_name))
                if not os.path.isdir(out_dir):
                    os.mkdir(out_dir)
                script_dir = os.path.join(out_dir, '%s_%d' % (saved_name, idx))
                filename = os.path.join(script_dir, "%s_%d.xlsx" % (saved_name, idx))
                
                # Save file
                if os.path.isdir(script_dir):
                    workbook.save(filename=filename)
                else:   
                    # Generate batch dir
                    os.mkdir(script_dir)
                    workbook.save(filename=filename)
                idx += 1
                col = 2
                workbook = load_workbook(filename=configs.template_file.dir)
                sheet = workbook[configs.template_file.workbook_name]

    elif "Parameter" in configs.template_file.dir:

        workbook = load_workbook(filename=configs.template_file.dir)
        columns = parameters_df.columns
        

        column_num = len(columns)
        sampling_num = parameters_df.shape[0]
        sheet = workbook['Parameter']
        batch_num = configs.dataset_generation.batch_num
        # split the parameters_df to batches with batch_num equals 
        batches = sampling_num // batch_num 
        remains = sampling_num % batch_num

        out_dir = os.path.abspath(os.path.join(os.getcwd(), configs.dataset_generation.dir, saved_name))
        if not os.path.isdir(out_dir):
            os.mkdir(out_dir)
        idx = 0
        for b in range(batches):
            script_dir = os.path.join(out_dir, '%s_%d' % (saved_name, idx))
            filename = os.path.join(script_dir, "%s_%d.xlsx" % (saved_name, idx))
            # Save file
            if not os.path.isdir(script_dir):
                os.mkdir(script_dir)
            
            with pd.ExcelWriter(filename) as writer:
                stackup_df.to_excel(writer, sheet_name='Stackup', index=False)
                
                parameters_df.iloc[idx * batch_num : (idx + 1) * batch_num].T.to_excel(writer, sheet_name='Parameter', header=False, engine='openpyxl')

            idx += 1
        if remains != 0 :
            script_dir = os.path.join(out_dir, '%s_%d' % (saved_name, idx))
            filename = os.path.join(script_dir, "%s_%d.xlsx" % (saved_name, idx))

            if not os.path.isdir(script_dir):
                os.mkdir(script_dir)
            
            with pd.ExcelWriter(filename) as writer:
                stackup_df.to_excel(writer, sheet_name='Stackup', index=False)
                parameters_df.iloc[idx * batch_num : sampling_num].T.to_excel(writer, sheet_name='Parameter', header=False)

        
        
        # for col in range(sampling_num):

            

        #     for row in range(column_num):
        #         sheet.cell(row=row+1, column=col, value=parameters_df.iloc[col, row])
            
        #     # Save the batch script
        #     if (col == batch_num+2) or (i == sampling_num-1):

        #         # write stackup sheet
        #         sheet = workbook['Stackup']
        #         for row in range(stackup_df.shape[0]):
        #             for col in range(stackup_df.shape[1]):
        #                 sheet.cell(row=row+1, column=col+1, value=stackup_df.iloc[row, col])

        #         # Define the output dir
        #         out_dir = os.path.abspath(os.path.join(os.getcwd(), configs.dataset_generation.dir, saved_name))
        #         if not os.path.isdir(out_dir):
        #             os.mkdir(out_dir)
        #         script_dir = os.path.join(out_dir, '%s_%d' % (saved_name, idx))
        #         filename = os.path.join(script_dir, "%s_%d.xlsx" % (saved_name, idx))
                
        #         # Save file
        #         if os.path.isdir(script_dir):
        #             workbook.save(filename=filename)
        #         else:   
        #             # Generate batch dir
        #             os.mkdir(script_dir)
        #             workbook.save(filename=filename)
        #         idx += 1
        #         col = 2
        #         workbook = load_workbook(filename=configs.template_file.dir)
        #         sheet = workbook[configs.template_file.workbook_name]
        # read
        

    else:
        raise NotImplementedError
    return

def read_input_feature_xlsx(
    sheet: str,
    template_file) -> np.ndarray:

    """
    Read templates' columns

    Args:
        sheet: Mixed_N_Line_Stripline | ...

    Returns:
        columns: np.ndarray of scripts columns
    """

    sheets = ['Mixed_N_Line_Stripline']
    
    skiprows = {
        'Mixed_N_Line_Stripline': 23,
    }

    if sheet not in sheets:
        raise ValueError(f"Sheet name {sheet} not defined.")
    
    para_df = pd.read_excel(template_file, sheet_name=sheet, skiprows=skiprows[sheet])
    return para_df.T.loc['batch list'].to_numpy()

def read_multilayer_input_features_xlsx(
    template_file: str
):
    """
    Read Metis multi-layer transmission lines scripts

    Args:
        template_file
    
    Returns:

    
    """
    # # load layer settings without the index
    # stackup_df = pd.read_excel(template_file, sheet_name="Stackup")
    # stackup_df = stackup_df.set_index('Layer Name')

    # # keep only the indeices contains "Metal"
    # metal_stackup_df = stackup_df[stackup_df.index.str.contains('Metal')]

    # load each layers parameter setting
    # load the excel by spliting each empty line
    parameter_df = pd.read_excel(template_file, sheet_name="Parameter", header=None)
    
    # switch the axis
    parameter_df = parameter_df.T
    # use the first row as column names
    parameter_df.columns = parameter_df.iloc[0]
    # drop the first row
    parameter_df = parameter_df.drop(0)
    
    return parameter_df

    # split the dataframe by empty lines into list of dataframes
    parameter_df_list = np.split(parameter_df, parameter_df[parameter_df.isnull().all(axis=1)].index)

    # remove NaN and 0 and 1 
    parameter_df_list = [df.dropna() for df in parameter_df_list]
    # for each dataframe, use the first column as index
    for i in range(len(parameter_df_list)):
        parameter_df_list[i] = parameter_df_list[i].set_index(0)

def read_script(
    excel_file: str,
    input_features: InputFeatures,
    configs: Config,
    samelines: bool = True) -> pd.DataFrame:
    """
    Read generated samples
    Args:
        parameters_df: pd.DataFrame of input parameters
        input_features: InputFeatures
        configs: Config
        samelines: bool, whether different lines have different W and S

    Return:
        parameters_df: pd.DataFrame
    """
    workbook = load_workbook(filename=excel_file)
    sheet_name = configs.template_file.workbook_name
    sheet = workbook[sheet_name]
    
    if sheet_name == 'Mixed_N_Line_Stripline':
        df = pd.read_excel(excel_file, sheet_name=sheet_name, skiprows=23)
        parameters_df = df.T.loc[df.T.index[1:]].copy()
        parameters_df.columns = df.T.loc['batch list'].to_numpy()
        parameters_df = parameters_df.set_index('save dir file name')
        parameters_df.index.name = None
        for p in parameters_df.columns:
            if (p == 'W' or p == 'S') and (parameters_df[p].apply(lambda x: isinstance(x, str)).all()):
                parameters_df[p] = parameters_df[p].str.split(',').apply(lambda x: float(x[0]))
            else:
                parameters_df[p] = parameters_df[p].astype(float)
    else:
        raise NotImplementedError
    
    return parameters_df
